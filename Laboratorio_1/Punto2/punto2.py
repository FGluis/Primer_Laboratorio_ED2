# -*- coding: utf-8 -*-
"""punto2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aHpmI0hWu-kLCkuLyxQcM6JZRKSz7oiw
"""

class Node(object):
  # Constructor de la clase nodo
  # Posee los atributos de direccion (derecha e izquierda)

    def __init__(self, data):
        self.data = data
        self.lChild = None
        self.rChild = None

class Tree(object):

   #En esta clase arbol creamos el abb, claramente su raiz es vacia
    #Tambien recibimos como argumento la cadena a encriptar 
    #Cabe recalcar que para la simplicidad de la experiencia solo utilizaremos
    #Los caracteres del alfabeto ('a-z') en minuscula, cualquier otro caracter sera rechazado

    def __init__(self, encrypt_str):
        self.root = None

        # Creamos una llave de encriptacion con caracteres de 'a-z' y posibles espacios
        self.buildEncryptStr(encrypt_str)

        # Creamos la un ABB con la llave encriptada haciendo uso del metodo insert
        for i in range(len(self.encryptStr)):
            self.insert(self.encryptStr[i])

    # En este metodo verificamos que no se coloque un caracter que no este especificado
    #Se entra una cadena como parametro, se pasa a minusculas
    #Luego recorremos la cadena y verificamos que este entre 'a-z' o contenga espacios
    #Y se agrega a una cadena vacia, la cual sera la llave 

    def buildEncryptStr(self, encrypt_str):
        self.encryptStr = encrypt_str
        self.encryptStr = self.encryptStr.lower()
        fixed = ''
        for i in range(len(self.encryptStr)):
            if ('a' <= self.encryptStr[i] and self.encryptStr[i] <= 'z') or (self.encryptStr[i] == ' '):
                fixed += self.encryptStr[i]
        self.encryptStr = fixed

    # Search for a node with the key
    def find(self, key):
        current = self.root

        while ((current != None) and (current.data != key)):
            if (key < current.data):
                current = current.lChild
            else:
                current = current.rChild

        return current

  # El metodo insert agrega un nodo que contenga un caracter (ch) en el abb, debemos tener 
  # en cuenta que si el caracter ya existe no lo podemos agregar ya que no puede haber
  # duplicados en el abb   
  
  #En el caso base, el nodo raiz empezara con none
  #Para la insercion veremos si el caracter a ingresar es menor o mayor al recurrente
  #Y lo colocaremos en lado izquierdo o derecho respectivamente 
  #De esta manera conservamos la estructura de abb y agregamos los nodos
    def insert(self, ch):
        
        if self.find(ch) != None:
            return

        newNode = Node(ch)
        if (self.root == None):
            self.root = newNode
        else:
            current = self.root
            parent = self.root
            while (current != None):
                parent = current
                if (ch < current.data):
                    current = current.lChild
                else:
                    current = current.rChild

            if (ch < parent.data):
                parent.lChild = newNode
            else:
                parent.rChild = newNode

     # El metodo buscar buscara el caracter en el abb y colocara un string dependiendo
     # de la cantidad de < o > que se llegaran a necesitar para alcanzar el caracter
     # se retornara un caracter vacio en caso tal de que exista un caracter que no este en el arbol
     # En el caso de la raiz, se denotara con un *
     # Los criterios para la asignacion de caracteres obviamente se hace segun el abb
     # En caso de que el caracter sea mayor que el nodo recurrente se coloca >
     # < en caso contrario 

    def search(self, ch):

        # Si la busqueda coincide con la raiz colocamos *
        if self.root.data == ch:
            return '*'

        # si el caracter a buscar no esta en el arbol coloca un espacio
        elif self.find(ch) == None:
            return ''

        path = ''
        current = self.root
        #Creamos un string donde mapeamos el camino para encontrar el caracter 
        #en el arbol
        while current != None and current.data != ch:
            if ch < current.data:
                path += '<'
                current = current.lChild
            else:
                path += '>'
                current = current.rChild

        return path

     # Este metodo ayuda a recorrer el arbol para buscar un caracter dada una serie de > o <
     # En caso tal de que el caracter no exista, como se ha hecho anteriormente se retornara un espacio vacio
   
    def traverse(self, st):
        current = self.root
        #Si el camino empieza con la raiz, su recorrido terminaria con la misma raiz
        if st[0] == '*':
            return current.data

        #Nos movemos a lo largo del ABB tal como diga el camino
        #Es decir, si existe < y el nodo es no vacio haremos el recorrido hacia izquierda
        #Analogo seria para >
        for i in range(len(st)):

            if st[i] == '<' and current.lChild != None:
                current = current.lChild

            elif st[i] == '>' and current.rChild != None:
                current = current.rChild

            else:
               #Si tenemos un camino inconsistente devolvemos una cadena vacia
                return ''

        return current.data

  #El metodo de encriptamiento toma una cadena como caracter y la lleva a su caso en minusculas
  # Retorna el string encriptado e ignorara cualquier tipo de caracter especial que sea ajeno a los casos
  # ya mencionados ('a-z')
  #Claramente llamamos al metodo search, para delimitar la diferencia de caracteres
  #Estaran separados por un !

    def encrypt(self, st):
        result = ''
        if st == '':
            return result

        st = st.lower()
        

        for i in range(len(st)):
          #Mientras el caracter este en el arbol (esto quiere decir en la llave)
          #Con el metodo buscar agregamos el path a encriptar y separamos cada caracter con !
            if st[i] in self.encryptStr:
                result += self.search(st[i]) + '!'
            #Si el caracter no esta en el arbol, la frase encriptada agrega el caracter y lo delimita con !
            else:
                result += st[i] + '!'
        #basado en el output, no vamos a incluir el delimitador resultate
        
        return result[:len(result) - 1]

  #Este metodo realiza lo contrario al de encriptamiento, dada la cadena de > y <
  #Haremos un split y luego mediante el recorrido podemos acceder a los caracteres almacenados 
  #En el abb 
    def decrypt(self, st):
        result = ''
        if st == '':
            return result

        check = ['<', '>', '*', '!']
       # Si se usa alguno de estos 4 caracteres para encriptar es que no pueden 
       # ser descifrados, es decir, si estos est√°n en el mensaje original no pueden
        # diferenciarse a partir del metodo de cifrado de esos caracteres.

        st = st.split('!')
        #Separamos la cadena encriptada haciendo uso del delimitador (!)

        for i in range(len(st)):
            checkFlag = True

            #Este booleano verifica que cada caracter es un camino valido o un delimitador
            #Para que el metodo de recorrido funcione
            

            for j in range(len(st[i])):
                if not (st[i][j] in check):
                    #Si no es un camino valido, agregamos el caracter al string
                    result += st[i][j]
                    checkFlag = False

            if checkFlag:
                result += self.traverse(st[i])

        return result


def main():
    key = str(input('Entra tu llave a encriptar: '))
    print()
    tree = Tree(key)

    inputStr = str(input('Mete el string que vas a encriptar: '))
    estr = tree.encrypt(inputStr)
    print('String encriptado: ' + estr)
    print()

    encryptedStr = str(input('Mete el string que quieres desencriptar: '))
    dstr = tree.decrypt(encryptedStr)
    print('String desencrriptado: ' + dstr)

main()